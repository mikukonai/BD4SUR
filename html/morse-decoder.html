<!-- Framework Iroha -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style/framework.css" charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="../style/markdown.css" charset="utf-8"/>
<title>BD4SUR CW Decoder</title>
<script src="../script/framework/jquery/jquery.min.js"></script>


<!--页面自定义样式开始-->
<style>


</style>
<!--页面自定义样式结束-->

</head>
<body>

<!--页面内容开始-->

<div style="margin: 50px auto; text-align: center;">
    <div style="font-size: 20px; font-weight: bold;">CW Morse Code Decoder</div>
    <div style="font-size: 15px;">BD4SUR</div>
    <canvas id="spectrum" style="height: 80px; width: 300px;" height="512px" width="512px"></canvas><br>
    <canvas id="spectrogram" style="height: 300px; width: 300px;" height="512px" width="512px"></canvas>
    <div id="copy" style="font-size: 18px; font-weight: bold;"></div>
    <div>2021年6月</div>
</div>


<!--页面内容结束-->

<!--脚本开始-->
<script src="../script/canvas.js"></script>
<script>

// 莫尔斯编码表
const Morse = {
    "01":   "A",   "1000": "B",  "1010": "C",   "100":  "D",   "0": "E",
    "0010": "F",   "110":  "G",  "0000": "H",   "00":   "I",   "0111": "J",
    "101":  "K",   "0100": "L",  "11":   "M",   "10":   "N",   "111": "O",
    "0110": "P",   "1101": "Q",  "010":  "R",   "000":  "S",   "1": "T",
    "001":  "U",   "0001": "V",  "011":  "W",   "1001": "X",   "1011": "Y",   "1100": "Z",

    "11111": "0", "01111": "1", "00111": "2", "00011": "3", "00001": "4",
    "00000": "5", "10000": "6", "11000": "7", "11100": "8", "11110": "9",

    "011010": "@", "001100": "?", "10010": "/", "101101": "()",
    "100001": "—", "010101": "。"
};

// 全局变量

const LONG_SIGN_DURATION = 13;

const FFT_SIZE = 1024;
const HALF_FFT_SIZE = FFT_SIZE / 2;

let timer = 0;              // 绝对时钟
let idleTimer = 0;          // 空闲时间时钟（即没有载波的空闲时间）
let prevCarrierFreq = -1;   // 上一个出现的载波的量化频点
let status = -1;            // 状态标识
let startTime, endTime;     // 某一符号的起始/终止时间戳
let prevSign = 0;           // 上一个符号（点/划）
let signString = "";        // 符号序列缓冲

const SPECTROGRAM_LENGTH = 512;
let spectrogram = [];

let words = new Array();

// HSV转RGB（[0,1]）
function HSV_to_RGB(h, s, v) {
    let hi = Math.floor(h / 60);
    let f = h / 60 - hi;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);
    switch(hi) {
        case 0: return [v, t, p];
        case 1: return [q, v, p];
        case 2: return [p, v, t];
        case 3: return [p, q, v];
        case 4: return [t, p, v];
        case 5: return [v, p, q];
        default: return [0, 0, 0];
    }
}

// dB转颜色
function dB2Color(dB) {

    const MIN = 0;
    const MAX = 255;

    let ratio = (dB - MIN) / (MAX - MIN);
    let hue, v;
    const threshold = 0.12;
    if(ratio < threshold) {
        v = 1 - (threshold - ratio) / threshold;
        hue = (1 - threshold) * (1 - threshold) * 360;
    }
    else {
        v = 1;
        hue = (1-ratio) * (1-ratio) * 360;
    }
    let rgb = HSV_to_RGB(hue, 1, v);

    return [
        ((rgb[0] * 255) | 0),
        ((rgb[1] * 255) | 0),
        ((rgb[2] * 255) | 0)
    ];
}

// 绘制声谱图
function RenderSpectrogram(cvContext, spectrogramBuffer) {
    let spectLength = spectrogramBuffer.length;

    // 每个像素4个byte(R.G.B.Alpha)
    let frameBuffer = new Uint8ClampedArray(spectLength * HALF_FFT_SIZE * 4);

    for(let t = 0; t < spectLength; t++) {
        let spect = spectrogramBuffer[t];
        // let carrierFreq = getCarrierFreq(spect);
        // console.log(carrierFreq);
        // 展开循环（duff's device）
        for(let i = 0; i < HALF_FFT_SIZE;) {
            let byteIndex, color;
            // 以下可以重复
            byteIndex = ((HALF_FFT_SIZE * (spectLength - t) + i) << 2);
            color = dB2Color(spect[i]);
            // if(i === carrierFreq) color = [255,255,255];
            frameBuffer[  byteIndex  ] = color[0]; frameBuffer[ byteIndex+1 ] = color[1];
            frameBuffer[ byteIndex+2 ] = color[2]; frameBuffer[ byteIndex+3 ] = 255;
            i++;
        }
    }

    let frame = new ImageData(frameBuffer, HALF_FFT_SIZE, spectLength);
    cvContext.putImageData(frame, 0, 0);
}

function RenderSpectrum(cvContext, spect) {
    const WIDTH = HALF_FFT_SIZE;
    const HEIGHT = HALF_FFT_SIZE;

    let spectLength = spect.length;

    cvContext.fillStyle = "#000";
    cvContext.fillRect(0, 0, WIDTH, HEIGHT);

    cvContext.lineWidth = 2;
    cvContext.strokeStyle = "#fff";

    cvContext.beginPath();

    let sliceWidth = WIDTH * 1.0 / spectLength;
    let x = 0;

    for(let i = 0; i < spectLength; i++) {
        let v = spect[i] / 128.0;
        let y = HEIGHT - v * HEIGHT / 2;
        if(i === 0) {
            cvContext.moveTo(x, y);
        }
        else {
            cvContext.lineTo(x, y);
        }
        x += sliceWidth;
    }

    cvContext.lineTo(WIDTH, HEIGHT);
    cvContext.lineTo(0, HEIGHT);
    // cvContext.stroke();
    cvContext.fillStyle = "#6cf";
    cvContext.fill();
}

// 检测载波的存在性以及位置。不存在明显载波，则返回-1，存在则返回载波频率所落入的量化频点。
function getCarrierFreq(frame) {
    // 计算频谱平坦度
    let avr = 0;
    for(let f = 0; f < frame.length; f++) {
        avr += frame[f];
    }
    avr /= frame.length;

    let maxIndex = -1;
    let maxValue = Number.MIN_VALUE;
    for(let f = 0; f < frame.length; f++) {
        if(frame[f] > maxValue) {
            maxIndex = f;
            maxValue = frame[f];
        }
    }

    // TODO 这里的算法非常关键，需要继续研究

    // console.log(avr / maxValue);

    // 如果方差小于某个阈值，则认为频谱平坦，不存在明显的峰值（载波）
    if(maxValue < 200) {
        return -1;
    }
    // 否则，取谱的最大值所在的量化频点，作为载波所在的频点。
    else {
        return maxIndex;
    }

}

// 电键按下，即载波出现（从无到有）
function keydown() {
    if(status === -1) {
        status = 0;
    }
    else if(status !== 0) {
        return;
    }

    startTime = timer;
    status = 1;
    // CW Start
}

// 电键抬起，即载波消失（从有到无）
function keyup() {
    // CW End
    endTime = timer;
    status = 0;

    let duration = endTime - startTime; // 符号持续时间
    let sign = 0;
    if(prevSign === 0 && duration >= LONG_SIGN_DURATION) sign = 1;
    else if(prevSign === 0 && duration < LONG_SIGN_DURATION) sign = 0;
    else if(prevSign === 1 && duration < LONG_SIGN_DURATION) sign = 0;
    else if(prevSign === 1 && duration >= LONG_SIGN_DURATION) sign = 1;

    signString += String(sign);
    prevSign = sign;
}

// 译码（触发时机为空闲了一个长划的时间以上）
function decodeWord() {
    let morseWord = Morse[signString];
    signString = "";
    return morseWord;
}




function decodeBuffer(frame) {

    let carrierFreq = getCarrierFreq(frame);

    // 前一帧没有载波
    if(prevCarrierFreq === -1) {
        // 空闲
        if(carrierFreq === -1) {
            idleTimer++;
        }
        // 按下电键
        else {
            idleTimer = 0;
            keydown();
        }
    }
    // 前一帧有载波
    else {
        // 电键抬起
        if(carrierFreq === -1) {
            idleTimer++;
            keyup();
        }
        // 电键继续按下
        else {
            idleTimer == 0;
        }
    }

    // 空闲时，翻译码字
    if(idleTimer >= LONG_SIGN_DURATION) {
        idleTimer = 0;
        let morseWord = decodeWord();
        if(morseWord) words.push(morseWord);
    }

    prevCarrierFreq = carrierFreq;
    timer++;
}


const cvSpectrogram = document.querySelector('#spectrogram');
const cvSpectrum = document.querySelector('#spectrum');

let audioCtx;
const cvCtxSpectrogram = cvSpectrogram.getContext("2d");
const cvCtxSpectrum = cvSpectrum.getContext("2d");

const constraints = { audio: true };

if(navigator.mediaDevices.getUserMedia) {

    let chunks = [];

    let onSuccess = (stream) => {
        const mediaRecorder = new MediaRecorder(stream);

        visualize(stream);
    };


    let onError = (err) => {
        console.log('The following error occured: ' + err);
    }


    navigator.mediaDevices.getUserMedia({
        audio: true
    }).then(onSuccess, onError);
}



function visualize(stream) {
    if(!audioCtx) {
        audioCtx = new AudioContext();
    }

    const source = audioCtx.createMediaStreamSource(stream);

    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    source.connect(analyser);

    let lastLen = 0;

    let listenTimer = setInterval(() => {
        analyser.getByteFrequencyData(dataArray);

        let frame = Array.from(dataArray);

        spectrogram.push(frame);
        if(spectrogram.length > SPECTROGRAM_LENGTH) spectrogram.shift();
        RenderSpectrum(cvCtxSpectrum, frame)
        RenderSpectrogram(cvCtxSpectrogram, spectrogram);

        decodeBuffer(frame);
        if(words.length > 0 && words.length > lastLen) {
            console.log(words);
            document.querySelector("#copy").innerHTML = words.join(" ");
        }
        lastLen = words.length;
    }, 20);

}




</script>
<!--脚本结束-->

</body>
</html>
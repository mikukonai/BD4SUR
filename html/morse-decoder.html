<!-- Framework Iroha -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="../style/framework.css" charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="../style/markdown.css" charset="utf-8"/>
<title>BD4SUR CW Decoder</title>
<script src="../script/framework/jquery/jquery.min.js"></script>


<!--页面自定义样式开始-->
<style>


</style>
<!--页面自定义样式结束-->

</head>
<body>

<!--页面内容开始-->

<div style="margin: 50px auto; text-align: center;">
    <div style="font-size: 20px; font-weight: bold;">CW Morse Code Decoder</div>
    <div style="font-size: 15px;">BD4SUR / 2021.6</div>
    <canvas id="spectrum" style="height: 150px; width: 300px;" height="256px" width="512px"></canvas><br>
    <canvas id="spectrogram" style="height: 300px; width: 300px;" height="512px" width="512px"></canvas>
    <div id="copy" style="font-size: 18px; font-weight: bold;"></div>
    <div id="sbEnergy"></div>
    <table id="sbDecode" style="font-size: 13px;">

    </div>
</div>


<!--页面内容结束-->

<!--脚本开始-->
<script src="../script/canvas.js"></script>
<script>

// 莫尔斯编码表
const Morse = {
    "01":   "A",   "1000": "B",  "1010": "C",   "100":  "D",   "0": "E",
    "0010": "F",   "110":  "G",  "0000": "H",   "00":   "I",   "0111": "J",
    "101":  "K",   "0100": "L",  "11":   "M",   "10":   "N",   "111": "O",
    "0110": "P",   "1101": "Q",  "010":  "R",   "000":  "S",   "1": "T",
    "001":  "U",   "0001": "V",  "011":  "W",   "1001": "X",   "1011": "Y",   "1100": "Z",

    "11111": "0", "01111": "1", "00111": "2", "00011": "3", "00001": "4",
    "00000": "5", "10000": "6", "11000": "7", "11100": "8", "11110": "9",

    "011010": "@", "001100": "?", "10010": "/", "101101": "()",
    "100001": "—", "010101": "。"
};

// 全局变量

const LONG_SIGN_DURATION = 200; // ms

const FFT_SIZE = 1024;
const HALF_FFT_SIZE = FFT_SIZE / 2;

const SUBBAND_WIDTH = 32;
const SUBBAND_NUMBER = HALF_FFT_SIZE / SUBBAND_WIDTH;

const DEBOUNCE_DELAY = 40;      // 边沿防抖延时

const ABSOLUTE_THRESHOLD = 100; // 绝对判定门限：低于这个值的不作为有效的信号
const TRIGGER_THRESHOLD = 50;   // 边沿触发门限

let idleTimer = [];          // 空闲时间时钟（即没有载波的空闲时间）
let prevCarrierFreq = [];   // 上一个出现的载波的量化频点
let status = [];            // 状态标识
let startTime = [];
let endTime = [];     // 某一符号的起始/终止时间戳
let prevSign = [];           // 上一个符号（点/划）
let signString = [];        // 符号序列缓冲

const SPECTROGRAM_LENGTH = 512;
let spectrogram = [];

let words = new Array();

for(let sb = 0; sb < SUBBAND_NUMBER; sb++) {
    $("#sbDecode").append(`<tr><td>SB_${sb}</td><td id="sb_${sb}"></td></tr>`);
}


// 推入队列
function pushIntoBuffer(element, buffer, bufferLength) {
    buffer.push(element);
    if(buffer.length > bufferLength) buffer.shift();
}

// HSV转RGB（[0,1]）
function HSV_to_RGB(h, s, v) {
    let hi = Math.floor(h / 60);
    let f = h / 60 - hi;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);
    switch(hi) {
        case 0: return [v, t, p];
        case 1: return [q, v, p];
        case 2: return [p, v, t];
        case 3: return [p, q, v];
        case 4: return [t, p, v];
        case 5: return [v, p, q];
        default: return [0, 0, 0];
    }
}

// dB转颜色
function dB2Color(dB) {

    const MIN = 0;
    const MAX = 255;

    let ratio = (dB - MIN) / (MAX - MIN);
    let hue, v;
    const threshold = 0.12;
    if(ratio < threshold) {
        v = 1 - (threshold - ratio) / threshold;
        hue = (1 - threshold) * (1 - threshold) * 360;
    }
    else {
        v = 1;
        hue = (1-ratio) * (1-ratio) * 360;
    }
    let rgb = HSV_to_RGB(hue, 1, v);

    return [
        ((rgb[0] * 255) | 0),
        ((rgb[1] * 255) | 0),
        ((rgb[2] * 255) | 0)
    ];
}

// 绘制声谱图
function RenderSpectrogram(cvContext, spectrogramBuffer) {
    let spectLength = spectrogramBuffer.length;

    // 每个像素4个byte(R.G.B.Alpha)
    let frameBuffer = new Uint8ClampedArray(spectLength * HALF_FFT_SIZE * 4);

    for(let t = 0; t < spectLength; t++) {
        let spect = spectrogramBuffer[t];
        // 展开循环（duff's device）
        for(let i = 0; i < HALF_FFT_SIZE;) {
            let byteIndex, color;
            // 以下可以重复
            byteIndex = ((HALF_FFT_SIZE * (spectLength - t) + i) << 2);
            color = dB2Color(spect[i]);
            frameBuffer[  byteIndex  ] = color[0]; frameBuffer[ byteIndex+1 ] = color[1];
            frameBuffer[ byteIndex+2 ] = color[2]; frameBuffer[ byteIndex+3 ] = 255;
            i++;
        }
    }

    let frame = new ImageData(frameBuffer, HALF_FFT_SIZE, spectLength);
    cvContext.putImageData(frame, 0, 0);
}

function RenderSpectrumAndPeaks(cvContext, spect, peaks) {
    const WIDTH = HALF_FFT_SIZE;
    const HEIGHT = HALF_FFT_SIZE / 2;

    let spectLength = spect.length;

    cvContext.fillStyle = "#000";
    cvContext.fillRect(0, 0, WIDTH, HEIGHT);

    cvContext.lineWidth = 2;
    cvContext.strokeStyle = "#fff";

    cvContext.beginPath();

    let sliceWidth = WIDTH * 1.0 / spectLength;
    let x = 0;

    for(let i = 0; i < spectLength; i++) {
        let v = spect[i] / 128.0;
        let y = HEIGHT - v * HEIGHT / 2;
        if(i === 0) {
            cvContext.moveTo(x, y);
        }
        else {
            cvContext.lineTo(x, y);
        }
        x += sliceWidth;
    }

    cvContext.lineTo(WIDTH, HEIGHT);
    cvContext.lineTo(0, HEIGHT);
    // cvContext.stroke();
    cvContext.fillStyle = "#6cf";
    cvContext.fill();



    // 绘制峰值点
    for(let i = 0; i < peaks.length; i++) {
        let peakIndex = peaks[i];
        x = sliceWidth * peakIndex;
        let y = HEIGHT - (spect[peakIndex] / 128.0) * HEIGHT / 2;
        cvContext.lineWidth = 3;
        cvContext.strokeStyle = "#ff0";
        cvContext.beginPath();
        cvContext.arc(x, y, 3, 0, 2 * Math.PI);
        cvContext.stroke();
    }
}


// 计算序列的滑动平均
function movingAverage(input, windowLength) {
    let output = [];
    output[0] = input[0];
    // 计算序列的前(windowLength-1)个点的平均
    for(let t = 1; t < windowLength - 1; t++) {
        let sum = 0;
        for(let i = 0; i <= t; i++) {
            sum += input[i];
        }
        output[t] = sum / t;
    }
    // 计算序列从下标为(windowLength-1)的点开始的其余点的滑动平均
    for(let t = (windowLength - 1); t < input.length; t++) {
        let sum = 0;
        for(let i = t - (windowLength - 1); i <= t; i++) {
            sum += input[i];
        }
        output[t] = sum / windowLength;
    }
    return output;
}

// 峰值检测
function detectPeaks(input) {
    // 自适应阈值：以序列的滑动平均线往上一段距离为峰值判定阈值
    let thresholds = movingAverage(input, Math.ceil(input.length / 50));
    const offset = 10;

    let peaks = [];
    let peakValue = Number.MIN_VALUE;
    let peakIndex = -1;
    for(let t = 0; t < input.length; t++) {
        let value = input[t];
        if(value > thresholds[t] + offset) {
            if(value > peakValue) {
                peakValue = value;
                peakIndex = t;
            }
        }
        else if(peakIndex > -1) {
            peaks.push(peakIndex);
            peakIndex = -1;
            peakValue = Number.MIN_VALUE;
        }
    }

    if(peakIndex > -1) {
        peaks.push(peakIndex);
    }

    return peaks;
}

// 检测载波的存在性以及位置。不存在明显载波，则返回-1，存在则返回载波频率所落入的量化频点。
function getCarrierFreq(frame) {
    // 计算频谱平坦度
    let avr = 0;
    for(let f = 0; f < frame.length; f++) {
        avr += frame[f];
    }
    avr /= frame.length;

    let maxIndex = -1;
    let maxValue = Number.MIN_VALUE;
    for(let f = 0; f < frame.length; f++) {
        if(frame[f] > maxValue) {
            maxIndex = f;
            maxValue = frame[f];
        }
    }

    // TODO 这里的算法非常关键，需要继续研究

    // console.log(avr / maxValue);

    // 如果方差小于某个阈值，则认为频谱平坦，不存在明显的峰值（载波）
    if(maxValue < 200) {
        return -1;
    }
    // 否则，取谱的最大值所在的量化频点，作为载波所在的频点。
    else {
        return maxIndex;
    }

}

// 电键按下，即载波出现（从无到有）
function keydown(index) {
    if(status[index] === undefined) {
        status[index] = 0;
    }
    else if(status[index] !== 0) {
        return;
    }

    startTime[index] = new Date().getTime();
    status[index] = 1;
    // CW Start
}

// 电键抬起，即载波消失（从有到无）
function keyup(index) {
    // CW End
    endTime[index] = new Date().getTime();
    status[index] = 0;

    let duration = endTime[index] - startTime[index]; // 符号持续时间
    let sign = 0;
    let signPrev = (prevSign[index] === undefined) ? 0 : prevSign[index];
    if(signPrev === 0 && duration >= LONG_SIGN_DURATION) sign = 1;
    else if(signPrev === 0 && duration < LONG_SIGN_DURATION) sign = 0;
    else if(signPrev === 1 && duration < LONG_SIGN_DURATION) sign = 0;
    else if(signPrev === 1 && duration >= LONG_SIGN_DURATION) sign = 1;

    if(signString[index] === undefined) signString[index] = "";
    signString[index] += String(sign);
    prevSign[index] = sign;
}

// 译码（触发时机为空闲了一个长划的时间以上）
function decodeWord(index) {
    let morseWord = Morse[signString[index]];
    signString[index] = "";
    return morseWord;
}




const cvSpectrogram = document.querySelector('#spectrogram');
const cvSpectrum = document.querySelector('#spectrum');

let audioCtx;
const cvCtxSpectrogram = cvSpectrogram.getContext("2d");
const cvCtxSpectrum = cvSpectrum.getContext("2d");

const constraints = { audio: true };

if(navigator.mediaDevices.getUserMedia) {

    let chunks = [];

    let onSuccess = (stream) => {
        const mediaRecorder = new MediaRecorder(stream);

        decodeAndVisualize(stream);
    };


    let onError = (err) => {
        console.log('The following error occured: ' + err);
    }


    navigator.mediaDevices.getUserMedia({
        audio: true
    }).then(onSuccess, onError);
}



function decodeAndVisualize(stream) {
    if(!audioCtx) {
        audioCtx = new AudioContext();
    }

    const source = audioCtx.createMediaStreamSource(stream);

    const analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    source.connect(analyser);

    let lastLen = 0;

    let prevEdgeTimestamp = [];

    let subbandFrameBuffer = [];

    let listenTimer = setInterval(() => {
        analyser.getByteFrequencyData(dataArray);

        let frame = Array.from(dataArray);
        // let frame = movingAverage(dataArray, 2); // 滑动平均
        let peaks = detectPeaks(frame);          // 峰值所在的量化频点

        // 对频谱作降采样，取带内最大值
        let subbandFrame = [];
        for(let i = 0; i < HALF_FFT_SIZE; i += SUBBAND_WIDTH) {
            let indexFrom = i;
            let indexTo = i + SUBBAND_WIDTH;
            let max = 0;
            for(let j = indexFrom; j < indexTo; j++) {
                if(frame[j] > max) max = frame[j];
            }
            subbandFrame.push(max);
        }
        pushIntoBuffer(subbandFrame, subbandFrameBuffer, 100);

/*
        let quantFrame = [];
        for(let i = 0; i < HALF_FFT_SIZE; i++) {
            let index = Math.floor(i / SUBBAND_WIDTH);
            quantFrame[i] = subbandFrame[index];
        }

        // 检测每个子带的载波存在情况
        const activeThreshold = 50; // 判定载波存在的阈值
        let sbEnergy = [];
        for(let i = 0; i < SUBBAND_NUMBER; i++) {
            let energy = 0;
            for(let t = 0; t < subbandFrameBuffer.length; t++) {
                energy += subbandFrameBuffer[t][i];
            }
            sbEnergy[i] = Math.round(energy / subbandFrameBuffer.length);
        }
        $("#sbEnergy").html(JSON.stringify(sbEnergy));
*/

        // 分子带检测边沿

        for(let i = 0; i < SUBBAND_NUMBER; i++) {
            let currentTimestamp = new Date().getTime();
            let currentSubband = subbandFrameBuffer[subbandFrameBuffer.length-1][i];

            if(currentSubband < ABSOLUTE_THRESHOLD) {
                continue;
            }

            if(currentTimestamp - prevEdgeTimestamp[i] <= 40) {
                continue;
            }

            // 前面若干点的滑动平均
            let avr = 0;
            const wlen = 4;
            for(let t = (subbandFrameBuffer.length - 2 - wlen); t < (subbandFrameBuffer.length - 2); t++) {
                avr += subbandFrameBuffer[t][i];
            }
            avr /= wlen;

            let delta = currentSubband - avr;

            // keydown
            if(delta > TRIGGER_THRESHOLD) {
                delta = 128;
                idleTimer[i] = Number.MAX_SAFE_INTEGER;
                keydown(i);
                console.log(`${i} down`);
                prevEdgeTimestamp[i] = currentTimestamp;
            }
            // keyup
            else if(delta < -TRIGGER_THRESHOLD){
                delta = 255;
                idleTimer[i] = new Date().getTime();
                keyup(i);
                console.log(`${i} up`);
                prevEdgeTimestamp[i] = currentTimestamp;
            }
            else {
                delta = 0;
            }
        }

        // 对每个子带进行解码
        for(let i = 0; i < SUBBAND_NUMBER; i++) {
            if(new Date().getTime() - idleTimer[i] > LONG_SIGN_DURATION) {
                idleTimer[i] = Number.MAX_SAFE_INTEGER;
                let morseWord = decodeWord(i);
                if(morseWord)
                    $(`#sb_${i}`).append(morseWord);
            }
        }

        // pushIntoBuffer(quantFrame, spectrogram, SPECTROGRAM_LENGTH);
        pushIntoBuffer(frame, spectrogram, SPECTROGRAM_LENGTH);

        RenderSpectrumAndPeaks(cvCtxSpectrum, frame, peaks);
        RenderSpectrogram(cvCtxSpectrogram, spectrogram);

    }, 10);

}




</script>
<!--脚本结束-->

</body>
</html>